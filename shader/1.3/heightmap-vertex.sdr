#version 130

uniform sampler2D heightMap;
uniform int vertsPerSide;

uniform mat4 xform;
//uniform mat4 rotate;
uniform mat4 projection; 

out vec4 world_pos;
out vec4 vs_normal;
out float vs_z;

float step = 1.0 / (vertsPerSide - 1);
float halfStep = step / 2.0;

vec2 uvForIndex(int index) {
    int row = index / (vertsPerSide * 2);
    bool evenRow = (mod(row, 2) == 0.0);

    int inRow = int( (mod(index, (vertsPerSide * 2))));
    int column = inRow / 2;
    int rowPlus = int( mod(inRow, 2));

    if (evenRow) {
        return vec2( step * column, step * (row + rowPlus)); 
    } else {
        return vec2( (vertsPerSide - column - 1) * step, (row + rowPlus) * step); 
    }    
}

vec4 toPosition(vec2 uv) {
    float z = texture(heightMap, uv).r;
 
    vec4 position = vec4( uv.x, z, uv.y, 1.0);
    position.xz *= 2.0;
    position.xz -= 1.0;

    return position;
}

vec3 across(vec2 priorUV, vec2 nextUV) {
    vec4 prior = toPosition(priorUV);
    vec4 next  = toPosition(nextUV);

    return next.xyz - prior.xyz;
}

vec2 clockOffset(int position) {
    //Computes an offset to the adjacent vertex, starting with the one
    //directly above and rotating clockwise around.
    vec2 offset = vec2(0.0, 0.0);

    switch (position) {
    case 0:
        offset.y = step;
        break;
    case 1:
        offset.x = step;
        offset.y = step;
        break;
    case 2:
        offset.x = step;
        break;
    case 4:
        offset.x = step;
        offset.y = -step;
        break;
    case 5:
        offset.y = -step;
        break;
    case 6:
        offset.x = -step;
        offset.y = -step;
        break;
    case 7:
        offset.x = -step;
        break;
    case 8:
        offset.x = -step;
        offset.y = step;
        break;
    }
    return offset; 
}

vec4 calculateNormal(vec2 uvCenter) {
    vec3 sumNormals = vec3(0.0, 0.0, 0.0);

    vec3 center = toPosition(uvCenter).xyz;

    vec2 lastOffset = clockOffset(0);

    for(int i=1; i<9; i++) {
        vec2 offset = clockOffset(i);

        vec3 leftPos  = toPosition(uvCenter + lastOffset).xyz;
        lastOffset = offset;
        if (leftPos.x < 0.0 || leftPos.x > 1.0 || leftPos.y < 0.0 || leftPos.y > 1.0) { continue; }

        vec3 rightPos = toPosition(uvCenter + offset).xyz;
        if (rightPos.x < 0.0 || rightPos.x > 1.0 || rightPos.y < 0.0 || rightPos.y > 1.0) { continue; }

        vec3 normal = cross(rightPos - center, leftPos - center);
        sumNormals += normalize(normal);
    };

    vec3 avgNormal = normalize(sumNormals);
    //out.w = 0.0;

    return vec4(avgNormal.xyz, 0.0);
}

vec3 xTangent(vec2 middle) {
    // Computes a "Tangent" by taking the height values halfway between the
    // previous and next points along the x axis.
    vec2 priorUV = clamp( vec2( middle.x - halfStep, middle.y), 0.0, 1.0);
    vec2 nextUV  = clamp( vec2( middle.x + halfStep, middle.y), 0.0, 1.0);

    return across(priorUV, nextUV);
}

vec3 yTangent(vec2 middle) {
    // Computes a "Tangent" by taking the height values halfway between the
    // previous and next points along the y axis.
    vec2 priorUV = clamp( vec2( middle.x, middle.y - halfStep), 0.0, 1.0);
    vec2 nextUV  = clamp( vec2( middle.x, middle.y + halfStep), 0.0, 1.0);

    return across(priorUV, nextUV);
}

void main(void) {
    vec2 uv = uvForIndex(gl_VertexID);

    vec4 position = toPosition(uv);

    vs_z = position.y;

    //vec4 normal = normalize( cross(yTangent(uv), xTangent(uv)) ).xyzz;
    //normal.w = 0.0;
    vec4 normal = calculateNormal(uv);
    
    world_pos = xform * position;
    gl_Position = projection * world_pos;

    vs_normal = xform * normal; 
}
